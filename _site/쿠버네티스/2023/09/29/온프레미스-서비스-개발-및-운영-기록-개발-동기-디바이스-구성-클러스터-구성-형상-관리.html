<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="bdg-blog" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>bdg-blog</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">bdg-blog</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#쿠버네티스">
				<span class="name">쿠버네티스</span>
				<span class="badge">10</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#기타">
				<span class="name">기타</span>
				<span class="badge">8</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#운영체제/컴퓨터구조">
				<span class="name">운영체제/컴퓨터구조</span>
				<span class="badge">7</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#백앤드">
				<span class="name">백앤드</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#컨테이너">
				<span class="name">컨테이너</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Go">
				<span class="name">Go</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 아키텍쳐">
				<span class="name">클린 아키텍쳐</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#보안">
				<span class="name">보안</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#리눅스">
				<span class="name">리눅스</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#네트워크">
				<span class="name">네트워크</span>
				<span class="badge">4</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#자바스크립트">
				<span class="name">자바스크립트</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 코드">
				<span class="name">클린 코드</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			온프레미스 서비스 개발 및 운영 기록 - 개발 동기, 디바이스 구성, 클러스터 구성, 형상 관리
		</div>
		<time class="post-date dt-published" datetime="2023-09-29T18:49:15+09:00" itemprop="datePublished">2023/09/29
		</time>		
	</header>

	<div class="post-content">
		<p>bdg.blog는 온프레미스로 쿠버네티스 위에서 동작하는 블로그 서비스입니다. bdg.blog는 ‘AWS Route 53’과 ‘Github’을 제외한 모든 기능을 온프레미스로 배포하고 있습니다. 이번 포스트에서는 쿠버네티스를 활용한 온프레미스 CI/CD 파이프라인의 구축 경험을 소개합니다.</p>

<hr />

<ul>
  <li>개발 동기
    <ul>
      <li>비용 문제</li>
      <li>공부 목적</li>
    </ul>
  </li>
  <li>디바이스 구성</li>
  <li>클러스터 구성
    <ul>
      <li>Kubernetes - K3s</li>
      <li>bdg.blog</li>
      <li>Harbor</li>
      <li>Minio</li>
      <li>Argo Events, Workflows, CD</li>
    </ul>
  </li>
  <li>형상 관리
    <ul>
      <li>kustomization</li>
      <li>helm chart + kustomization</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="개발-동기">개발 동기</h1>

<h2 id="비용-문제">비용 문제</h2>

<p>처음 블로그 서비스를 배포했을 때는 AWS를 사용했습니다. 컨테이너 없이 AWS 위에 서버를 실행해서 배포하는 구조로 간단한 구조였습니다. 하지만 가장 낮은 스팩으로 배포하더라도 데이터베이스 비용, 인스턴스 운영 비용이 발생한다는 단점이 있었습니다.</p>

<h2 id="공부-목적">공부 목적</h2>

<p>온프레미스에서 앱, DB, 스토리지 서버, CI/CD 파이프라인을 모두 구축하는 것은 상업적 관점에서 봤을 때 비효율적입니다. 하지만 클라우드에서 해결해주는 여러 문제를 직접 겪어 보면 시스템을 공부하는 데 큰 도움이 될 것으로 생각해 이 프로젝트를 시작했습니다.</p>

<h1 id="디바이스-구성">디바이스 구성</h1>

<p>2개의 노트북을 묶어 하나의 쿠버네티스 클러스터를 구성했습니다. 네트워크 스위치는 가정용 공유기를 사용하고 있으며, Public IP의 80 포트, 443 포트가 이 클러스터로 연결됩니다.</p>

<p><img alt="image" src="/images/93f29256-b61c-482b-b132-6f3cc79e3750" /></p>

<ul>
  <li>2개의 노트북으로 구성</li>
  <li>ubuntu 22.04</li>
  <li>k3s v1.25.7</li>
</ul>

<h3 id="비용-측면">비용 측면</h3>

<p>위의 구성으로 24시간동안 항상 서버를 실행하고 있습니다. 혼자 사는데 필요한 생활 전력(냉장고, 에어컨, 각종 전자기기, 데스크탑 컴퓨터)을 포함하여 전기세를 한달에 2 ~ 3만원 정도 지출하고 있습니다. 생활 전기 비용이 포함되어 있기 때문에 명확한 비교는 힘들지만, 크게 부담되는 비용은 아닙니다. 만약 이 서비스를 모두 AWS에서 운영했을 때와 비교해도 비용면에서 충분히 효율적이라고 판단했습니다.</p>

<h1 id="클러스터-구성">클러스터 구성</h1>

<p>하나의 쿠버네티스 클러스터에 아래 앱들이 고유의 namespace를 가지고 운영되고 있습니다. 형상을 정의하는 yaml파일들은 github에 저장되며, 아래 링크에서 확인하실 수 있습니다.</p>

<ul>
  <li>https://github.com/deagwon97/bdg-blog-v2/tree/main/deploy</li>
</ul>

<p><img alt="image" src="/images/45520b0d-a4b4-4a2a-82ed-c6265293a5f5" /></p>

<h3 id="kubernetes---k3s">Kubernetes - K3s</h3>

<p>구축하려는 클러스터는 고성능 서버가 아닌 노트북 위에 설치해야 합니다. 실제 K8s와 호환되면서도 Edge Device에서 잘 동작하는 K3s로 클러스터를 구성하기로 했습니다. K3s는 containerd(컨테이너 런타임), flannel (CNI), traefik(Ingress Controller)를 기본 설정으로 사용합니다. 다른 옵션을 구성할 수도 있지만, 불필요하다고 판단하고 기본 설정을 그대로 사용했습니다.</p>

<h3 id="bdgblog">bdg.blog</h3>

<p>NextJs로 개발한 블로그 서비스입니다. 링크에 자세한 설명이 포함되어 있습니다.</p>

<ul>
  <li><a href="https://deagwon.com/post/bdg-blog%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%93%A4%EC%97%88%EB%8D%98-%EA%B3%A0%EB%AF%BC%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EA%B5%AC%EC%A1%B0-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B0%A9%EB%B2%95-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95">https://deagwon.com/post/bdg-blog를-만들면서-들었던-고민과-해결-방법-프로그램-구조-사용한-도구-테스트-방법-개발-환경-구축</a></li>
</ul>

<h3 id="harbor">Harbor</h3>

<p>초기에는 AWS의 ECR를 사용했습니다. 비용 문제로인해서 Harbor로 이전하는 것을 선택했습니다.</p>

<h3 id="minio">Minio</h3>

<p>Image File을 저장하기 위한 Object Storage 입니다. bdg.blog에서는 minio에 이미지 다운로드 및 업로드를 위한 presigned url을 발급하여 클라이언트로 전달합니다. 클라이언트는 발급받은 URL로 minio 서버에 파일을 바로 업로드합니다.</p>

<h3 id="argo-events-workflows-cd">Argo Events, Workflows, CD</h3>

<p>CI/CD 구축을 위해서 사용한 도구들 입니다. 처음에는 Jenkins를 사용했지만, 잦은 plugin 업데이트 문제, 네이티브로 쿠버네티스 컨테이너를 지원하지 않는 문제 등을 이유로 Argo로 이전했습니다. 링크(<a href="https://deagwon.com/post/KubernetesArgoCD-Argo-WorkflowsEvents-%EB%8F%84%EC%9E%85%EA%B8%B0">https://deagwon.com/post/KubernetesArgoCD-Argo-WorkflowsEvents-도입기</a>)에 자세히 정리해 두었습니다.</p>
<ul>
  <li>마주했던 문제점<br />
 단순히 공식문서에 나온 방법으로 CI 파이프라인을 구축하면, namespcae별로 구분되는 argo ci를 구성할 수 없었습니다. namespace 속에 argoci를 구축한 후, 다른 namespace에 독립적인 argoci를 설치하려고 했었습니다. 분명히 namespace가 분리되어 있음에도 불구하고, 두 argoci는 동시에 동작하지 못 했습니다.</li>
  <li>원인<br />
 argo events와 argo workflows의 설치 스크립트를 살펴보면 CustomResourceDefinition 을 생성하며 ClusterRole 을 정의합니다. 그리고 이 둘은 하나의 Cluster Scope에서 동작합니다. 만약 B 프로젝트를 위해서 ClusterRole 수정하면, 기존의 A 프로젝트는 정상적으로 동작하지 못하게 되는 것입니다.</li>
  <li>해결책<br />
이 문제를 해결하기 위해 Cluster Scope에서 동작하는 CustomResourceDefinition 과 ClusterRole 는 따로 설치하고, namespace 범위에서 동작하는 자원들만 분리했더니 Argo Events, Argo CD 를 프로젝트단위로 설치할 수 있었습니다.</li>
</ul>

<p><img alt="image" src="/images/10b72dbd-da9b-42ee-9e1c-8d721dcf35fc" /></p>

<p><img alt="image" src="/images/730b1afc-d3c2-4809-86cf-5cbe4956ae5f" /></p>

<h1 id="형상-관리">형상 관리</h1>

<h2 id="kustomization">kustomization</h2>

<p>프로젝트의 모든 앱은 kustomization 으로 관리하고 있습니다. 아래와 같이 자원 명세를 작성하고 <code class="highlighter-rouge">kubectl apply -k</code> 명령을 통해서 배포합니다. 또한 이 명세서는 모두 git과 argo cd를 통해서 관리합니다. argo cd는 git에 올라간 형상과 실제 클러스터 형상을 비교하고 차이점을 알려 줍니다. (자동으로 형상을 동기화할 수 있지만, 현재는 형상이 잘 유지되고 있는지 확인하는 용도로만 사용합니다.)</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">------- production 폴더 구조 -------</span>
<span class="c1"># 프로비저닝 순서에 따라서 yaml 파일에 순서를 부여했습니다.</span>
<span class="s">production</span>
<span class="pi">|--</span> <span class="err">00namespace.yaml</span>
<span class="err">|</span><span class="s">-- 01dockerconfig.json # gitignore</span>
<span class="err">|</span><span class="s">-- 01dockerconfig.json.example</span>
<span class="err">|</span><span class="s">-- 01nextjs.env        # gitignore</span>
<span class="err">|</span><span class="s">-- 01nextjs.env.example</span>
<span class="err">|</span><span class="s">-- 03serviceAccount.yaml</span>
<span class="err">|</span><span class="s">-- 04deployment.yaml</span>
<span class="err">|</span><span class="s">-- 05service.yaml</span>
<span class="err">|</span><span class="s">-- 11issuer.yaml</span>
<span class="err">|</span><span class="s">-- 12certificate.yaml</span>
<span class="err">|</span><span class="s">-- 13middleWare.yaml</span>
<span class="err">|</span><span class="s">-- 14ingressRouter.yaml</span>
<span class="err">`</span><span class="s">-- kustomization.yaml</span>

<span class="err">-</span><span class="s">------ kustomization.yaml -------</span>
<span class="err">a</span><span class="s">piVersion: kustomize.config.k8s.io/v1beta1</span>
<span class="err">k</span><span class="s">ind: Kustomization</span>
<span class="err">n</span><span class="s">amespace: bdg-blog</span>
<span class="err">m</span><span class="s">etadata:</span>
  <span class="s">name: arbitrary</span>
<span class="err">#</span><span class="s"># generate secret only first time</span>
<span class="err">#</span><span class="s"> secretGenerator:</span>
<span class="err">#</span><span class="s">   - name: bdg-blog</span>
<span class="err">#</span><span class="s">     envs:</span>
<span class="err">#</span><span class="s">     - 01nextjs.env</span>
<span class="err">#</span><span class="s">   - name: bdg-blog-regcred</span>
<span class="err">#</span><span class="s">     files:</span>
<span class="err">#</span><span class="s">       - .dockerconfigjson=01dockerconfig.json</span>
<span class="err">#</span><span class="s">     type: kubernetes.io/dockerconfigjson</span>
<span class="err">r</span><span class="s">esources:</span>
  <span class="s">- 00namespace.yaml</span>
  <span class="s">- 03serviceAccount.yaml</span>
  <span class="s">- 04deployment.yaml</span>
  <span class="s">- 05service.yaml</span>
  <span class="s">- 11issuer.yaml</span>
  <span class="s">- 12certificate.yaml</span>
  <span class="s">- 13middleWare.yaml</span>
  <span class="s">- 14ingressRouter.yaml</span>
</code></pre></div></div>

<h2 id="helm-chart">Helm Chart</h2>

<p>쿠버네티스 패키지를 관리하는 방법은 kustomize 말고도 다양합니다. 일부 오픈 소스는 Helm Chart를 통해서 패키지를 배포하기도 합니다. 이 프로젝트에서 사용된 컨테이너 레지스트리 Harbor 또한 Helm Chart를 사용합니다.</p>

<p>하지만 Helm은 일부자원을 추가하는데 제약이 있습니다. 정의된 values.yaml 파일을 수정할 수만 있습니다. 만약 PersistentVoulme을 생성하거나, ingress, issuer와 같은 자원을 추가로 만들고 관리하기 위해서는 새로운 helm chart를 패키징해야 합니다.</p>

<p>저는 배포되는 Harbor의 Helm Chart를 그대로 사용하면서도, 원하는 자원들을 추가하기 위해 kustomize와 helm을 결합해서 사용했습니다.</p>

<p><img alt="image" src="/images/b2cf6afd-164f-4069-86d4-9236af39e4cd" /></p>

<p>이렇게 구성하면, 나중에 Harbor의 Helm Chart가 업데이트되더라도, 다시 Chart를 처음부터 작성하지 않고 해당 Chart의 버전만 업데이트할 수 있습니다. 또한, 형상이 모두 코드로 표현되기 때문에, ArgoCD를 통한 Continuous Deployment가 가능합니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kustomize.config.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Kustomization</span>
<span class="na">namespace</span><span class="pi">:</span> <span class="s">bdg-blog-harbor</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">bdg-blog-harbor</span>
<span class="na">generatorOptions</span><span class="pi">:</span>
  <span class="na">disableNameSuffixHash</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">resources</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">00namespace.yaml</span>
<span class="pi">-</span> <span class="s">01harbor-pv.yaml</span>
<span class="pi">-</span> <span class="s">02harbor-pvc.yaml</span>
<span class="pi">-</span> <span class="s">03issuer.yaml</span>
<span class="pi">-</span> <span class="s">04certificate.yaml</span>
<span class="pi">-</span> <span class="s">05ingress.yaml</span>
<span class="na">helmCharts</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">includeCRDs</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">harbor</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">bdg-blog-harbor</span>
  <span class="na">releaseName</span><span class="pi">:</span> <span class="s">harbor</span>
  <span class="na">repo</span><span class="pi">:</span> <span class="s">https://helm.goharbor.io</span>
  <span class="na">valuesFile</span><span class="pi">:</span> <span class="s">06harbor-helm-values.yaml</span>
  <span class="na">version</span><span class="pi">:</span> <span class="s">1.11.1</span>
</code></pre></div></div>

<p>주의할 점은 argocd config에서 <code class="highlighter-rouge">enable-helm</code>을 설정해야 helmChart를 argocd에서 사용할 수 있습니다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">argocd-cm</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">kustomize.buildOptions</span><span class="pi">:</span> <span class="s">--enable-helm</span>
  <span class="s">...</span>
</code></pre></div></div>

<h1 id="클러스터-구조-및-의존-관계">클러스터 구조 및 의존 관계</h1>

<p><img alt="image" src="/images/9b7a70fc-5581-4232-b467-1132e9f916f0" /></p>

<p>쿠버네티스 클러스터에는 다양한 서비스들이 동작하며, 네임스페이스를 통해 구분됩니다. 앱의 소스 코드 및 배포를 위한 명세 파일은 하나의 GitHub 레포지토리에서 관리됩니다.</p>

<ul>
  <li>MariaDB, Redis, Minio, NextJS 로 구성된 블로그</li>
  <li>CI/CD tools: kaniko, harbor, argo workflows, argo events, argo cd</li>
</ul>

<h3 id="continuous-integration----검은색-화살표">Continuous Integration -  검은색 화살표</h3>

<p>소스코드를 git에 push하면서 발생하는 일련의 자동 배포 과정입니다. git은 argo events에 webhook을 보내고, argo events는 정해진 workflow를 실행하면서 kaniko로 컨테이너 이미지를 빌드합니다. 이후 빌드가 완료되면 이미지를 harbor repository에 push합니다. 마지막으로 <code class="highlighter-rouge">kubectl restart rollout deployment bdg-blog -n bdg-blog</code> 명령어를 실행하면서 기존의 컨테이너들을 교체하면서 소스코드가 서비스에 적용됩니다.</p>

<h3 id="continuous-delivery---주황색-화살표">Continuous Delivery - 주황색 화살표</h3>

<p>ArgoCD를 활용한 Continuous Delivery  과정입니다. bdg.blog의 클러스터 명세는 secret 및 config 설정을 제외한 모든 코드가 kustomization.yaml 파일에 작성되어 있고, 이 파일은 동일한 git repository에 저장됩니다. 클러스터 명세를 수정하여 git에 push하면, ArgoCD는 이 명세의 설정과 클러스터의 상태를 비교하여 변경사항을 반영하도록 구성했습니다.</p>

<h3 id="network-flow---파란색-화살표">Network Flow - 파란색 화살표</h3>

<p>Ingress 컨트롤러인 traefik이 외부에서 들어오는 요청을 중계하는 과정을 보여줍니다. bdg.blog 외에도 harbor, minio, argo 모두 관리용 web ui를 제공합니다. 클라이언트가 요청한 도메인에 따라서 적절한 앱으로 요청이 라우팅 됩니다.</p>

<h2 id="reference">Reference</h2>

<ul>
  <li>https://k3s.io/</li>
  <li>https://goharbor.io/</li>
  <li>https://min.io/</li>
  <li>https://argoproj.github.io/</li>
  <li>https://kustomize.io/</li>
  <li>https://helm.sh/</li>
  <li>https://trstringer.com/helm-kustomize/</li>
</ul>


	</div>
	<br/>
	<br/>
	<script src="https://utteranc.es/client.js"
        repo="deagwon97/deagwon97.github.io"
        issue-term="url"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</article>
		</div>
	</div>
  </body>
</html>