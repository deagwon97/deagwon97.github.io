<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="bdg-blog" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>bdg-blog</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">bdg-blog</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#쿠버네티스">
				<span class="name">쿠버네티스</span>
				<span class="badge">10</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#기타">
				<span class="name">기타</span>
				<span class="badge">8</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#운영체제/컴퓨터구조">
				<span class="name">운영체제/컴퓨터구조</span>
				<span class="badge">7</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#백앤드">
				<span class="name">백앤드</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#컨테이너">
				<span class="name">컨테이너</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Go">
				<span class="name">Go</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 아키텍쳐">
				<span class="name">클린 아키텍쳐</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#보안">
				<span class="name">보안</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#리눅스">
				<span class="name">리눅스</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#네트워크">
				<span class="name">네트워크</span>
				<span class="badge">4</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#자바스크립트">
				<span class="name">자바스크립트</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 코드">
				<span class="name">클린 코드</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			[Go][Python] gRPC 맛보기
		</div>
		<time class="post-date dt-published" datetime="2023-07-26T20:01:53+09:00" itemprop="datePublished">2023/07/26
		</time>		
	</header>

	<div class="post-content">
		<h1 id="grpc란">gRPC란?</h1>

<p><img alt="image" src="/images/be601982-c404-4b27-921b-2a1d263cd0f1" /></p>

<blockquote>
  <p>gRPC란 구글에서 개발한 <strong>RPC</strong>(remote procedure call) 시스템이다.</p>
</blockquote>

<p>gRPC는 데이터 전송을 위해서 <strong>HTTP/2</strong>를 사용하고, <strong>IDL</strong>(interface description language)로 <strong>Protocal Buffer</strong>를 사용한다. 또한 인증, 양방향 스트리밍, blocking, nonblocking 바인딩 등 다양한 기능을 제공한다.</p>

<h2 id="rpcremote-procedure-call">RPC(Remote procedure call)</h2>
<blockquote>
  <p>분산 시스템에서, 하나의 프로그램이 실행하는 도중 <strong>다른 주소공간</strong>(다른 프로세스, 다른 컴퓨터..)의 <strong>프로시저</strong>(서브루틴)을 실행하는 것을 <strong>RPC</strong>라고 부른다.</p>
</blockquote>

<p>RPC 는 <strong>request–response protocol</strong>로 동작한다. 원래 프로그램은 다른 주소공간으로 reqeust를 보내고, 이 요청을 받은 서버는 프로시저를 실행하여 그 결과를 다시 원래 프로그램으로 보낸다(response).</p>

<p>이러한 RPC의 구현체로</p>
<ul>
  <li>Google의 <strong>gRPC</strong></li>
  <li>Facebook의 <strong>Thrift</strong></li>
  <li>Twitter의 <strong>Finalge</strong></li>
</ul>

<p>등 이 있다.</p>

<h2 id="http2">HTTP/2</h2>
<p>HTTTP/1.1의 단점 중** 프로토콜의 성능에 초첨**을 맞춰 개선한 전송 프로토콜이다. 기존의 HTTP/2는 다음과 같은 개선사항을 갖는다.</p>

<ul>
  <li><strong>Multiplexed Streams</strong>
    <ul>
      <li><strong>하나의 Connection</strong>에서 동시에 여러 개의 메시지를 주고 받는 기술이다. <strong>순서에 상관없이</strong> Stream으로 응답을 받을 수 있다.</li>
    </ul>
  </li>
  <li><strong>Stream Prioritization</strong>
    <ul>
      <li><strong>리소스 간의 의존관계</strong>에 따른 우선순위를 설정하여 리소스 로드한다.</li>
    </ul>
  </li>
  <li><strong>Server Push</strong>
    <ul>
      <li>서버가 클라이언트가 <strong>요청하지 않은 리소스</strong>를 클라이언트에게 보내는 기능이다.</li>
    </ul>
  </li>
  <li><strong>Header Compression</strong>
    <ul>
      <li>Header Table과 Huffman Encoding 기법을 통해 <strong>헤더의 중복을 줄이고, 압축</strong>하는 기능이다.</li>
    </ul>
  </li>
</ul>

<h2 id="protocol-buffers">protocol buffers</h2>
<blockquote>
  <p>protocol buffers는 구글에서 공개한 cross-platform 포맷으로, IDL의 한 종류이다. 구조화된 데이터를 언어, 플랫폼에 중립적으로 serializing(데이터를 저장될 수 있는 형태로 변환하는 것)하는 방법을 제한다.</p>
</blockquote>

<h3 id="간단한-proto-작성-예시">간단한 .proto 작성 예시</h3>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span> <span class="c1">// proto3, proto2 중에 사용할 버전 명시</span>

<span class="kn">package</span> <span class="nn">proto_test</span><span class="p">;</span> <span class="c1">// package 이름 명시</span>

<span class="kd">service</span> <span class="n">RpcService</span> <span class="p">{</span> <span class="c1">// RPC service 이름 정의(CamelCase with an initial capital)</span>
  <span class="k">rpc</span> <span class="err">함수명</span> <span class="p">(</span><span class="err">입력</span><span class="n">Message</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="err">출력</span><span class="n">Message</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="err">입력</span><span class="n">Message</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="err">출력</span><span class="n">Message</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">code</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">symbol</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="idlinterface-definition-language">IDL(Interface Definition Language)</h3>
<blockquote>
  <p>IDL은 서로 같거나 다른 소프트웨어 컴포넌트들 사이의 데이터 구조와 인터페이스를 묘사하기 위한 명세 언어이다.</p>
</blockquote>

<p>IDL은 어느 한 언어에 국한되지 않는 언어중립적인 방법으로 인터페이스를 표현함으로써, 같은 언어를 사용하지 않는 소프트웨어 컴포넌트 사이의 통신을 가능하게 한다.</p>

<h2 id="grpc-구성">gRPC 구성</h2>

<p><img alt="image" src="/images/5e8c092c-39ed-460c-ae2a-d5f87f2d5885" /></p>

<p>gRPC는 gRPC 서버와, gRPC클라이언트(stub)로 구성된다.</p>
<ul>
  <li>
    <p>gRPC 서버
service의 함수들이 서버의 언어로 정의되어 있어, stub에서 요청이 들어오면 이를 수행한다.</p>
  </li>
  <li>
    <p>gRPC클라이언트(stub)
정의된 proto파일에 맞는 변환 함수를 가지고 있다. service에 있는 함수를 호출하려면, stub의 언어로 생성된 데이터를 serializing하여 gRPC서버로 전송하고, 그 결과값을 다시 역 serializing한다.</p>
  </li>
</ul>

<h2 id="grpc-compile">gRPC compile</h2>
<p>언어별로 gRPC compiler를 통해 .proto파일을 각 언어 맞는 파일로 변환할 수 있다. 우선 .proto 파일을 작성한 후, 공통된 .proto파일을 통해서 server와 client에서 각각 compile한다.</p>

<h3 id="1-proto-파일-작성">1) .proto 파일 작성</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syntax</span> <span class="p">=</span> <span class="s2">"proto3"</span><span class="p">;</span>

<span class="k">package</span> <span class="n">helloworld</span><span class="p">;</span>

<span class="p">//</span> <span class="n">The</span> <span class="n">greeting</span> <span class="n">service</span> <span class="n">definition</span><span class="p">.</span>
<span class="n">service</span> <span class="n">Greeter</span> <span class="p">{</span>
  <span class="p">//</span> <span class="n">Sends</span> <span class="n">a</span> <span class="n">greeting</span>
  <span class="n">rpc</span> <span class="n">SayHello</span> <span class="p">(</span><span class="n">HelloRequest</span><span class="p">)</span> <span class="n">returns</span> <span class="p">(</span><span class="n">HelloReply</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="p">//</span> <span class="n">The</span> <span class="n">request</span> <span class="n">message</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">user</span><span class="s1">'s name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</span></code></pre></div></div>

<h3 id="2-server-compile">2) server compile</h3>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>protoc <span class="nt">--proto_path</span><span class="o">=</span>&lt;.proto파일의 dir경로&gt; <span class="se">\</span>
<span class="gp">		 --go_out=plugins=grpc:&lt;정의한 package이름&gt;</span><span class="w">  </span><span class="se">\</span>
<span class="go">        .proto파일
</span></code></pre></div></div>
<h3 id="3-client-compile">3) client compile</h3>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>python <span class="nt">-m</span> grpc_tools.protoc <span class="se">\</span>
<span class="gp">			--proto_path &lt;.proto파일의 dir경로&gt;</span><span class="w"> </span><span class="se">\</span>
<span class="gp">			--python_out=&lt;출력 .py파일 경로&gt;</span><span class="w"> </span><span class="se">\</span>
<span class="gp">            --grpc_python_out=&lt;출력 .py파일 경로&gt;</span><span class="w"> </span><span class="se">\</span>
<span class="gp">	        &lt;.proto파일경로&gt;</span><span class="w">
</span></code></pre></div></div>

<h2 id="grpc-life-cycle">gRPC life cycle</h2>

<h3 id="uray단방향-rpc">Uray(단방향) RPC</h3>
<p>가장 단순한 RPC이다. Cilent가 요청을 보내고, Server가 그 요청을 받으면 결과 값을 반환하는 구조이다.</p>
<h3 id="server-streaming-rpc">Server streaming RPC</h3>
<p>Uray와 비슷하지만, Server가 응답으로 streaming message를 보낸다는 차이가 있다. 서버는 streaming message가 모두 전송될때, 서버의 status혹은 다른 meta data를 추가로 전송한다.</p>
<h3 id="client-streaming-rpc">Client streaming RPC</h3>
<p>Uray와 비슷하지만, Cilent가 요청으로 streaming message를 보낸다는 차이가 있다. 서버는 streaming message가 모두 받으면 single response(필수x)를 보낸다.</p>
<h3 id="bidirectional-streaming-rpc">Bidirectional streaming RPC</h3>
<p>Client가 특정 함수를 호출하여 Sercer가 client metadata, method name, deadline을 받으면 시작된다. Server와 Client가 서로 동시에 스트리밍 데이터를 주고 받을 수 있고, 이 두 스트림은 독립적이다.</p>

<h2 id="example">Example</h2>
<ul>
  <li>https://github.com/deagwon97/grpc-go-python</li>
</ul>

<h2 id="reference">Reference</h2>
<ul>
  <li>https://en.wikipedia.org/wiki/GRPC</li>
  <li>https://brownbears.tistory.com/512</li>
  <li>https://chacha95.github.io/2020-06-15-gRPC1/</li>
  <li>https://en.wikipedia.org/wiki/Remote_procedure_call</li>
  <li>https://seokbeomkim.github.io/posts/http1-http2/</li>
  <li>https://yoongrammer.tistory.com/14</li>
  <li>https://developers.google.com/protocol-buffers/docs/overview</li>
  <li>https://www.grpc.io/docs/what-is-grpc/introduction/</li>
</ul>

	</div>
	<br/>
	<br/>
	<script src="https://utteranc.es/client.js"
        repo="deagwon97/deagwon97.github.io"
        issue-term="url"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</article>
		</div>
	</div>
  </body>
</html>