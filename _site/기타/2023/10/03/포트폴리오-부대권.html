<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="bdg-blog" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>bdg-blog</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">bdg-blog</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#쿠버네티스">
				<span class="name">쿠버네티스</span>
				<span class="badge">10</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#기타">
				<span class="name">기타</span>
				<span class="badge">8</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#운영체제/컴퓨터구조">
				<span class="name">운영체제/컴퓨터구조</span>
				<span class="badge">7</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#백앤드">
				<span class="name">백앤드</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#컨테이너">
				<span class="name">컨테이너</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Go">
				<span class="name">Go</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 아키텍쳐">
				<span class="name">클린 아키텍쳐</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#보안">
				<span class="name">보안</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#리눅스">
				<span class="name">리눅스</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#네트워크">
				<span class="name">네트워크</span>
				<span class="badge">4</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#자바스크립트">
				<span class="name">자바스크립트</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 코드">
				<span class="name">클린 코드</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			포트폴리오-부대권
		</div>
		<time class="post-date dt-published" datetime="2023-10-03T12:53:56+09:00" itemprop="datePublished">2023/10/03
		</time>		
	</header>

	<div class="post-content">
		<hr />

<ul>
  <li><strong>PART1</strong>: <strong>bdg.blog - 온프레미스 블로그 서비스</strong>
    <ul>
      <li>온프레미스 CI/CD 파이프라인 개발</li>
      <li>블로그 포스팅 서비스 bdg.blog 개발 (프론트앤드&amp;백앤드)</li>
    </ul>
  </li>
  <li><strong>PART2:</strong>  <strong>유지엘소프트 (도시과학 빅데이터 AI연구원 파견근무)</strong>
    <ul>
      <li>분산 파일시스템(glusterfs) 도입 및 <strong>성능 실험</strong></li>
      <li>slurm job컨테이너화</li>
      <li>사용자의 자원 사용률 모니터링 웹서비스 개발 (프론트앤드&amp;백앤드)</li>
      <li>다이나믹 리버스 프록시 서버 개발 및 성능 실험</li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="part1-bdgblog---온프레미스-블로그-서비스">PART1: bdg.blog - 온프레미스 블로그 서비스</h1>

<p>온프레미스로 쿠버네티스 위에서 동작하는 블로그 서비스입니다. 블로그 포스팅과 간단한 토이프로젝트 들을 서비스하고 있습니다.</p>

<h2 id="1-온프레미스-cicd-파이프라인-개발">1. 온프레미스 CI/CD 파이프라인 개발</h2>

<h3 id="a-link">a. Link</h3>

<ul>
  <li>Github: https://github.com/deagwon97/bdg-blog-v2/tree/main/deploy</li>
  <li>Post: <a href="https://deagwon.com/post/%EC%98%A8%ED%94%84%EB%A0%88%EB%AF%B8%EC%8A%A4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%9C%EB%B0%9C-%EB%B0%8F-%EC%9A%B4%EC%98%81-%EA%B8%B0%EB%A1%9D-%EA%B0%9C%EB%B0%9C-%EB%8F%99%EA%B8%B0-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EA%B5%AC%EC%84%B1-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EA%B5%AC%EC%84%B1-%ED%98%95%EC%83%81-%EA%B4%80%EB%A6%AC">https://deagwon.com/post/온프레미스-서비스-개발-및-운영-기록-개발-동기-디바이스-구성-클러스터-구성-형상-관리</a></li>
</ul>

<p><img alt="image" src="/images/78e03093-7919-47b9-9d49-14efc88fb13d" /></p>

<h3 id="b-클러스터-구조">b. 클러스터 구조</h3>

<p><img alt="image" src="/images/df3e466f-32e6-4aef-a52a-6e879e412516" /></p>

<p>클러스터에는 다양한 서비스들이 공존하며, 네임스페이스를 통해 구분됩니다. 앱의 소스 코드 및 배포를 위한 명세 파일은 하나의 GitHub 레포지토리에서 관리됩니다.</p>

<ul>
  <li>검은색 화살표:  소스코드를 Git에 push하면서 발생하는 자동 배포 과정</li>
  <li>주황색 화살표: ArgoCD를 활용한 Continuous Delivery</li>
  <li>파란색 화살표: Ingress 컨트롤러인 traefik이 외부에서 들어오는 요청을 중계하는 과정</li>
</ul>

<h3 id="d-마주했던-문제점-1---cluster-scope-중복-정의">d. 마주했던 문제점 1 - Cluster Scope 중복 정의</h3>

<ul>
  <li>문제점
    <ul>
      <li>Cluster Scope를 고려하지 않고, 여러 Namespace에서 Argo Workflows, Argo Events, Argo CD를 설치</li>
      <li>서로다른 namespace에서 Argo 설정이 충돌하는 상황 발생</li>
    </ul>
  </li>
  <li>해결
    <ul>
      <li>Cluster Scope에서 동작하는 자원들은 프로젝트와는 별도로 설치</li>
      <li>namespace 범위에서 동작하는 자원들만 프로젝트에 따라 추가하는 방식으로 분할</li>
    </ul>
  </li>
</ul>

<h3 id="e-마주했던-문제점-2---harbor의-helm-charts를-그대로-사용하면서-원하는-자원을-추가할-수-있을까">e. 마주했던 문제점 2 - Harbor의 Helm Charts를 그대로 사용하면서 원하는 자원을 추가할 수 있을까?</h3>

<ul>
  <li>문제점
    <ul>
      <li>Helm Chart를 통해서 Harbor를 설치할 경우, values.yaml 이외의 다른 자원을 추가할 수 없음</li>
      <li>새롭게 Helm Chart를 구성하는 것도 방법이지만, 나중에 Harbor 버전이 업데이트 될 때, 관리 포인트가 증가하는 문제가 존재</li>
    </ul>
  </li>
  <li>해결책
    <ul>
      <li>Helm과 kustomization을 결합하하여 문제를 해결</li>
    </ul>
  </li>
</ul>

<h2 id="2-블로그-포스팅-서비스-bdgblog-개발">2. 블로그 포스팅 서비스 bdg.blog 개발</h2>

<h3 id="a-link-1">a. Link</h3>

<ul>
  <li>Github: https://github.com/deagwon97/bdg-blog-v2/tree/main/src</li>
  <li>Post: <a href="https://deagwon.com/post/bdg-blog%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%93%A4%EC%97%88%EB%8D%98-%EA%B3%A0%EB%AF%BC%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EA%B5%AC%EC%A1%B0-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%8F%84%EA%B5%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B0%A9%EB%B2%95-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95">https://deagwon.com/post/bdg-blog를-만들면서-들었던-고민과-해결-방법-프로그램-구조-사용한-도구-테스트-방법-개발-환경-구축</a></li>
</ul>

<h3 id="b-프로그램-구조">b. 프로그램 구조</h3>

<p>프로그램의 가장 중요한 요소가 ‘요구사항을 만족하는 동작을 수행하는 것’ 이라면, 두 번째로 중요한 요소는 기능 확장성과 유지 보수성입니다. 저는 이 두가지 요소를 만족하는 서비스를 만들기 위해 다음과 같은 구조로 서비스를 만들었습니다.</p>

<p><img alt="image" src="/images/c48c62a4-d874-4ce8-8144-6afec6aaed12" /></p>

<h3 id="c-마주했던-문제점-1---테스트-코드가-db에-영향을-주는-문제">c. 마주했던 문제점 1 - 테스트 코드가 DB에 영향을 주는 문제</h3>

<ul>
  <li>문제점
    <ul>
      <li>처음 테스트 코드를 작성했을 때 DB에 직접적으로 값을 추가했다가 지우는 방식으로 테스트 코드를 작성함</li>
      <li>실제 배포되고 있는 서버에 테스트 내용이 순간적으로 반영되는 문제 발생</li>
    </ul>
  </li>
  <li>해결책
    <ul>
      <li>db transaction 을 활용하여, 테스트를 수행한 후 테스트가 성공하면 rollback하여 실제로 db에는 영향을 주지 않도록 구현</li>
    </ul>
  </li>
</ul>

<h3 id="d-마주했던-문제점-2---개발-환경과-배포-환경의-불일치">d. 마주했던 문제점 2 - 개발 환경과 배포 환경의 불일치</h3>

<ul>
  <li>배경
    <ul>
      <li>초기에는 컨테이너 없이 개발한 후 배포용 컨테이너를 만들고 배포</li>
    </ul>
  </li>
  <li>문제점
    <ul>
      <li>개발, 빌드, 배포 환경이 모두 달라 로컬에서 잘 빌드되는 코드도 실제 배포 환경에서는 빌드하지 못하는 문제 발생</li>
      <li>단순히 빌드 - 개발 - 배포를 하나의 컨테이너로 수행하면, 배포 시점에는 필요하지 않은 소스 코드나 프로그램이 포함되어, 배포 비용이 증가</li>
    </ul>
  </li>
  <li>해결
    <ul>
      <li>
        <p>VS Code의 devcontainer 사용하여 개발 - 빌드 환경 통일</p>

        <p>VS Code의 devcontainer를 활용하면 VScode editor가 컨테이너에 원격으로 접속하여 개발할 수 있었습니다. 이를 통해서 이미지를 빌드하는 환경과 개발 환경을 일치시켰습니다.</p>
      </li>
      <li>
        <p>Docker의 Multi Stage Build 사용하여 배포할 때 불필요한 파일 제거</p>

        <p>실제 배포 시에는 사용하지 않는 소스 코드와 프로그램을 제거하여 배포되는 컨테이너의 크기를 크게 줄일 수 있었습니다.</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="part2-유지엘소프트도시과학-빅데이터-ai연구원-파견근무">PART2: 유지엘소프트(도시과학 빅데이터 AI연구원 파견근무)</h1>

<h2 id="1-도시과학-빅데이터-ai연구원ubai란">1. 도시과학 빅데이터 AI연구원(UBAI)란?</h2>

<p>UBAI는 서울시립대학교 내에 위치하며, HPC 클러스터를 보유한 기관입니다. 교내외 연구원에게 고성능컴퓨팅 자원과 사용환경을 제공하고 있습니다. 저는 2022년 8월부터 지금까지 유지엘소프트에서 파트타임으로 근무하며 파견 형식으로 UBAI의 업무를 수행하고 있습니다. UBAI에서는 사용자 계정 관리, 시스템 문제 해결, 웹 어플리케이션(MyUBAI) 개발 등 다양한 업무를 수행합니다.</p>

<ul>
  <li>클러스터 스팩
    <ul>
      <li>CPU: Intel Xeon Gold 6240R 2.4GHz 48 cores, 6348R 2.6GHz 56 cores</li>
      <li>MEM: 768GB ~ 1024GB</li>
      <li>GPU: NVIDIA A100, NVIDIA RTX3090, NVIDIA A10</li>
    </ul>
  </li>
  <li>SLURM
    <ul>
      <li>SLURM(Simple Linux Utility for Resource Management)</li>
      <li>HPC(고성능 컴퓨팅) 클러스터에서 작업 스케줄링과 자원 관리를 위해 사용되는 오픈 소스의 자원 관리 시스템</li>
      <li>UBAI는 사용자에게 Linux 계정을 발급해 준 후, SLURM을 통해서 작업을 수행하는 방식으로 사용 클러스터를 사용</li>
    </ul>
  </li>
</ul>

<h2 id="2-분산-파일시스템glusterfs-도입-및-성능-실험">2. 분산 파일시스템(glusterfs) 도입 및 성능 실험</h2>

<ul>
  <li>소스코드: https://github.com/deagwon97/glusterfs-performance</li>
  <li>포스트: <a href="https://deagwon.com/post/NFS%EC%97%90%EC%84%9C-%EB%B6%84%EC%82%B0-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-Glusterfs%EB%A1%9C-%EC%A0%84%ED%99%98">https://deagwon.com/post/NFS에서-분산-파일-시스템-Glusterfs로-전환</a></li>
</ul>

<h3 id="a-배경">a. 배경</h3>

<p>기존의 파일시스템은 모든 Client 노드가 하나의 물리적 볼륨을 공유하는 NFS 를 사용하고 있었습니다. NFS에 연결된 노드 수와 사용량이 증가하면서 NFS I/O 속도가 감소하고, 메타 데이터가 충돌하는 등 여러 문제가 발생했습니다. 여러 분산 파일 시스템을 조사한 후 glusterfs를 도입하기로 결정했습니다. 하지만 glusterfs에서도 다양한 조합이 존재했고, 최적의 조합을 결정하기 위해 실험을 진행했습니다.</p>

<h3 id="b-실험을-통한-의사결정---최적의-glusterfs-조합-결정">b. 실험을 통한 의사결정 - 최적의 glusterfs 조합 결정</h3>

<p>4가지 조합에 대해, 단일파일과 다중 파일의 입출력 속도를 측정했습니다.</p>

<ul>
  <li>Distributed 8</li>
  <li>Disperse 8 (Redundancy 2)</li>
  <li>Distributed 4 Replicated 2</li>
  <li>Distributed 2 Disperse 4 (Redundancy 1)</li>
</ul>

<p>최대 2개의 볼륨이 고장 나더라도 모든 데이터를 복원할 수 있으며, 전체 하드디스크 용량의 75 %를 사용할 수 있는 조합 중, 가장 선능이 우수한  distributed 2, dispersed 4, redundancy 1 조합을 사용하기로 결정했습니다.</p>

<h3 id="c-마주했던-문제점---다중-파일-동시-입출력-구현">c. 마주했던 문제점 - 다중 파일 동시 입출력 구현</h3>

<ul>
  <li>배경
    <ul>
      <li>동시 파일 I/O 작업을 위해서 linux background process (&amp;) 사용</li>
    </ul>
  </li>
  <li>문제점
    <ul>
      <li>subprocess를 생성하는 overhead가 한 파일을 쓰는 속도와 유사하여 대역폭 측정이 불가능</li>
    </ul>
  </li>
  <li>해결책
    <ul>
      <li>Named Pipe (FIFO) 를 사용하여 subprocess를 생성하는 overhead를 94% 감소 시키고 유의미한 실험 결과를 얻음</li>
    </ul>
  </li>
</ul>

<h2 id="3-slrum-job-컨테이너-enroot-도입">3. SLRUM Job 컨테이너 enroot 도입</h2>

<h3 id="a-소개">a. 소개</h3>

<p>Slurm은 쿠버네티스나 도커와 같은 일반적인 컨테이너 도구를 지원하지 않습니다. 환경은 Linux Environment Modules을 통해서 구성하고 사용했었지만, 많은 문제점들이 있었습니다. 이를 해결하기위해 반쪽짜리 컨테이너 enroot를 도입했습니다.</p>

<ul>
  <li>포스트: <a href="https://deagwon.com/post/HPC-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EC%97%90-%EB%B0%98%EC%AA%BD-%EC%A7%9C%EB%A6%AC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-enroot-%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%98%EB%A9%B0-%EB%B0%B0%EC%9A%B4-%EA%B2%83%EB%93%A4">https://deagwon.com/post/HPC-클러스터에-반쪽-짜리-컨테이너-enroot-를-적용하며-배운-것들</a></li>
</ul>

<h3 id="b-마주했던-문제점--pxe-boot">b. 마주했던 문제점 – pxe boot</h3>

<ul>
  <li>문제점
    <ul>
      <li>grubby를 사용한 kernel command line 수정이 안 됨</li>
    </ul>
  </li>
  <li>원인
    <ul>
      <li>HPC 클러스터는 PXE boot 방식을 통해서 부팅함</li>
    </ul>
  </li>
  <li>해결책
    <ul>
      <li>PXE 서버에서 노드별 부팅 설정파일에 kernel command line을 추가하여 해결</li>
    </ul>
  </li>
</ul>

<h2 id="4-사용자의-자원-사용률-모니터링-웹서비스-개발-프론트앤드백앤드">4. 사용자의 자원 사용률 모니터링 웹서비스 개발 (프론트앤드&amp;백앤드)</h2>

<h3 id="a-소개-1">a. 소개</h3>

<p>사용자가 제출한 slurm job의 실제 사용량을 기록하고, 조회하는 어플리케이션 입니다.</p>

<ul>
  <li>사이트 링크: https://myubai.uos.ac.kr/main</li>
</ul>

<p><img alt="image" src="/images/e4dbdab8-361c-4b8f-b64e-3e589f74929e" /></p>

<h3 id="a-개발-동기">a. 개발 동기</h3>

<p>대부분의 모니터링 프로그램은, 컨테이너 혹은 노드 단위의 자원 사용량을 수집하거나, 고정된 PID를 갖는 프로세스의 사용량만 추적할 수 있었습니다. 실시간으로 생성되고 종료되는 프로세스를 UID별로 수집하고 집계하면서도 시스템 부하를 최소화하는 사용률 집계 프로그램이 필요했습니다.</p>

<h3 id="b-사용한-도구">b. 사용한 도구</h3>

<ul>
  <li>mariadb, python api server, linux crontab, ssh, shell script</li>
</ul>

<h3 id="c-동작-방식">c. 동작 방식</h3>

<p><img alt="image" src="/images/f1042196-aef0-4f55-b905-9fddd7afe1d5" /></p>

<ol>
  <li>5분 간격으로 master node에서 100개의 노드에 ssh로 접근하여 프로세스별 자원 사용률을 측정합니다. (linux top command, nvidia pmon command)</li>
  <li>측정된 정보를 파싱하여 다시 master node에서 동작하는 python api server에 Post Call하면 서버는 입력받은 raw 데이터를 Maria DB에 저장합니다.</li>
  <li>사용자가 조회하는 비용을 줄이기 위해 1시간 간격으로 raw 데이터를 가공하여 다시 processed 테이블에 저장합니다.</li>
  <li>외부에서 접속 가능한 노드에 MyUBAI(웹 어플리케이션)를 배포하고, 사용자는 MyUBAI를 통해 자신의 사용률을 실시간으로 조회합니다.</li>
</ol>

<h3 id="d-마주했던-문제">d. 마주했던 문제</h3>

<ul>
  <li>배경
    <ul>
      <li>초기에는MyUBAI의 백앤드 서버가 Raw 데이터 테이블에 직접 접근하여 사용률을 집계함</li>
      <li>Raw 데이터 테이블의 인덱스가 적절하게 설정되지 않음</li>
    </ul>
  </li>
  <li>문제점
    <ul>
      <li>인덱스가 적절하게 설정되지 않아, 조회 시간 30s 이상 소요</li>
      <li>인덱스를 최적화 하더라도 조회 시간 1.7s이상 소요</li>
    </ul>
  </li>
  <li>해결
    <ul>
      <li>1시간 간격으로 raw 데이터를 가공하여 processed 테이블에 다시 저장하는 스크립트를 작성</li>
      <li>MyUBAI의 백앤드 서버는 processed 테이블을 조회하는 방식으로 수정하여 조회 속도를 다시 <strong>46ms로 단축</strong></li>
    </ul>
  </li>
</ul>

<h2 id="3-다이나믹-리버스-프록시-서버-개발-및-성능-실험">3. 다이나믹 리버스 프록시 서버 개발 및 성능 실험</h2>

<ul>
  <li>소스코드: https://github.com/deagwon97/subdomain-tcp-proxy</li>
  <li>포스트: <a href="https://deagwon.com/post/subdomain-%EA%B8%B0%EB%B0%98-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%B0%9C-%EB%B0%8F-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90">https://deagwon.com/post/subdomain-기반-다이나믹-리버스-프록시-서버-개발-및-성능-비교</a></li>
</ul>

<h3 id="a-소개-2">a. 소개</h3>

<p>UBAI를 통해서 연구하시는 분 중에는 Linux 및 환경 구축에 미숙한 분들도 계십니다. 이분들을 대상으로 사용자 교육 및 화상 지원을 진행했지만, 저 혼자 이 많은 분들을 모두 감당하는 것은 한계가 있었습니다. 이론적으로 외부접속이 가능한 노드에 동적 터널링 서버를 개발한다면, 사용자가 Web UI를 통해서 손쉽게 연구 환경을 구성하고, 연구를 진행할 수 있다고 판단하여 개발을 시작했습니다.</p>

<h3 id="b-실험을-통한-의사결정---다이나믹-리버스-프록시-서버의-개발-언어-선택-nodejs-vs-golang">b. 실험을 통한 의사결정 - 다이나믹 리버스 프록시 서버의 개발 언어 선택 Node.js vs golang</h3>

<ul>
  <li>배경
    <ul>
      <li>목적지의 ip, port가 동적으로 바뀌면 이를 실시간으로 포워딩하는 프로그램이 필요</li>
      <li>Node.js는 높은 동시성을 지원하며, I/O 작업에서 효율적</li>
      <li>golang은 고루틴(Goroutines)을 통해 간단하면서도 효과적인 동시성 프로그래밍이 가능하면서 컴파일 언어로 빠른 실행 속도를 제공함.</li>
      <li>두 언어 중 적합한 언어를 선택해야 함</li>
    </ul>
  </li>
  <li>실험 결과 비교
    <ul>
      <li>성능 비교
        <ul>
          <li>일부 조건에서는 Go가 Node.js보다 2~3배 빠르게 동작했지만, 대부분의 상황에서 유사한 성능을 보임</li>
        </ul>
      </li>
      <li>안정성 비교
        <ul>
          <li>Go: 서로 다른 5000개의 tcp connection을 안정적으로 유지함</li>
          <li>Node.js: tcp connection 수가 4000개를 넘어서면서 오류가 발생함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>결론적으로 Go와 Node.js의 성능은 큰 차이가 없었습니다. 다만, 안정성 측면에서 Go가 Nod.js 보다 우수한 결과를 보여주었고, 처음 만들었던 Node.js 기반 중계 서버가 아닌 Go를 사용하기로 결정했습니다.</p>


	</div>
	<br/>
	<br/>
	<script src="https://utteranc.es/client.js"
        repo="deagwon97/deagwon97.github.io"
        issue-term="url"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</article>
		</div>
	</div>
  </body>
</html>