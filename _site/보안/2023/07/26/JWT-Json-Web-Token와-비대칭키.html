<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="bdg-blog" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>bdg-blog</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">bdg-blog</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#쿠버네티스">
				<span class="name">쿠버네티스</span>
				<span class="badge">10</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#기타">
				<span class="name">기타</span>
				<span class="badge">8</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#운영체제/컴퓨터구조">
				<span class="name">운영체제/컴퓨터구조</span>
				<span class="badge">7</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#백앤드">
				<span class="name">백앤드</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#컨테이너">
				<span class="name">컨테이너</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Go">
				<span class="name">Go</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 아키텍쳐">
				<span class="name">클린 아키텍쳐</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#보안">
				<span class="name">보안</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#리눅스">
				<span class="name">리눅스</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#네트워크">
				<span class="name">네트워크</span>
				<span class="badge">4</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#자바스크립트">
				<span class="name">자바스크립트</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 코드">
				<span class="name">클린 코드</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			JWT (Json Web Token)와 비대칭키
		</div>
		<time class="post-date dt-published" datetime="2023-07-26T19:57:37+09:00" itemprop="datePublished">2023/07/26
		</time>		
	</header>

	<div class="post-content">
		<h2 id="1-jwt란">1. JWT란?</h2>

<p>JSON object를 사용하여 정보 전달을 암호화 하는 방법의 일종으로 공개된 표준이다. JWT는 편리하고(compact) 자가수용적인 (self-contained) 방식으로 정보를 안전성 있게 전달한다.</p>

<h3 id="자가-수용적-self-contained">자가 수용적 (Self-Contained)?</h3>

<p>JWT 는 필요한 모든 정보를 JWT 스스로 가지고 있다. JWT 시스템에서 발급된 토큰은 “<strong>토큰에 대한 기본정보</strong>”, “<strong>전달 할 정보</strong>” 그리고 “<strong>토큰의 유효성을 검증할 정보</strong>”를 포함한다.</p>

<h2 id="2-jwt의-구성">2. JWT의 구성</h2>

<h3 id="1-header">1) Header</h3>

<p>알고리즘 형식 (RSA / SHA256 등)을 정의한다.</p>

<ul>
  <li><strong>alg : 서명 암호화 알고리즘(ex: HMAC SHA256, RSA)</strong></li>
  <li><strong>typ : 토큰 유형</strong></li>
</ul>

<h3 id="2-payload">2) Payload</h3>

<p>토큰에서 사용할 정보의 조각들인 <strong>Claim</strong> 이 담겨있다. (실제 JWT 를 통해서 알 수 있는 데이터) 즉, 서버와 클라이언트가 주고받는 시스템에서 실제로 <strong>사용될 정보에 대한 내용</strong>이다.</p>

<h3 id="3-signature">3) Signature</h3>

<p>토큰이 유효함을 나타내는 정보이다.  signature는 사용자가 조작할 수 없다.</p>

<h2 id="3-jwt의-동작-방식">3. JWT의 동작 방식</h2>

<p><img alt="image" src="/images/a73f54d8-3468-4f83-8d27-bee30c93379d" /></p>

<h3 id="1-jwt-생성">1) JWT 생성</h3>

<p>JWT는 Header와 Payload를 인코딩하여 합친 후, 특정 알고리즘을 통해서 암호화하여 signature를 생성한다.</p>

<blockquote>
  <p>encoding(Header) + encoding(Payload) → <strong>encryption →</strong> signature</p>

</blockquote>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">header</span> <span class="o">=</span> <span class="p">{</span>
	<span class="dl">"</span><span class="s2">alg</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">HMACSHA256</span><span class="dl">"</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">typ</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">JWT</span><span class="dl">"</span>
<span class="p">}</span>

<span class="nx">payload</span> <span class="o">=</span> <span class="p">{</span>
	<span class="dl">"</span><span class="s2">user_id</span><span class="dl">"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">bdg</span><span class="dl">"</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">class</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">2</span><span class="dl">"</span>
	<span class="p">...</span>
<span class="p">}</span>

<span class="nx">signature</span> <span class="o">=</span> <span class="nx">HMACSHA256</span><span class="p">(</span>
  <span class="nx">base64UrlEncode</span><span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span> <span class="o">+</span>
  <span class="nx">base64UrlEncode</span><span class="p">(</span><span class="nx">payload</span><span class="p">),</span>
  <span class="nx">secret</span><span class="p">)</span>

<span class="nx">JWT</span> <span class="o">=</span> <span class="nx">base64UrlEncode</span><span class="p">(</span><span class="nx">header</span><span class="p">).</span><span class="nx">base64UrlEncode</span><span class="p">(</span><span class="nx">payload</span><span class="p">).</span><span class="nx">signatue</span>
</code></pre></div></div>

<h3 id="2-jwt-소비">2) JWT 소비</h3>

<p>사용자는 base64 decodeing을 통해서 header와 payload를 쉽게 얻을 수 있다. 하지만, secret은 서버만 알고 있기 때문에 header와 payload를 수정한 후 signature를 다시 만들 수 없다. 사용자는 서버로부터 발급 받은 JWT를 그대로 소비하기만 하고, 수정없이 다시 서버로 전달한다.</p>

<h3 id="3-유효성-검증">3) 유효성 검증</h3>

<p>서버는 사용자가 다시 보내온 JWT의  header와 payload로 signature를 다시 생성하여 사용자가 보낸 signature와 비교한다. 이 두 signature가 일치할 경우, 사용자가 JWT를 수정하지 않았음이 증명된다.</p>

<p>payload가 수정되지 않았음이 증명되었기 때문에, 사용자는 payload에 들어있는 사용자 id를 신뢰할 수 있고, 이를 통해서 사용자를 식별할 수 있다.</p>

<h2 id="4-비대칭-키를-활용한-jwt">4. 비대칭 키를 활용한 JWT</h2>

<p>비대칭 키를 활용할 경우, <strong>인가</strong>(<strong>Athorization</strong>)을 제 3의 어플리케이션이 수행할 수 있다.</p>

<h3 id="1-비대칭-키-암호화란">1) 비대칭 키 암호화란?</h3>

<p>한 쌍의 키가 존재하고, 상대방의 키로 암호화한 값을 자신의 키로 복호화 할 수 있는 방식을 비대칭 키 암호화 방식이라고 부른다.</p>

<p>예를 들어 A, B 라는 2개의 키가 존재한다고 가정해 보자</p>

<p>우선 “<strong>중요한 값</strong>“을 A를 통해서 암호화 하겠다.</p>

<blockquote>
  <p>A(“<strong>중요한 값</strong>”) ⇒ ”<strong>암호화 된 값</strong>”</p>
</blockquote>

<p>이 ”<strong>암호화 된 값</strong>”은 B를 통해서 복호화한다.</p>

<blockquote>
  <p>B(”<strong>암호화 된 값</strong>”) ⇒ “<strong>중요한 값</strong>”</p>
</blockquote>

<p>여기서 특이한 점은 <strong>A로는 암호화된 값을 복호화 할 수 없다.</strong> 오로지 자신이 암호화한 값은 다른 키로 만 복호화가 가능하다.</p>

<blockquote>
  <p>A(”<strong>암호화 된 값</strong>”) ⇒ “<strong>중요한 값” — (X)</strong></p>
</blockquote>

<h3 id="2-비대칭키-적용한-jwt-인증인가-방식">2) 비대칭키 적용한 JWT 인증/인가 방식</h3>

<p>위의 “JWT의 동작 방식”에서는 HMACSHA256 알고리즘과 secret 이라는 하나의 키값을 통해서 암호화 하였다. 또한 특별히 복호화의 과정을 거치지 않았다. 하지만 이럴 경우, secret을 모르는 제3의 서비스는 JWT가 유효한지 그렇지 않은지 판단할 수 없다.</p>

<p>여기에 <strong>비대킹 키</strong>를 적용해 보자. 한쌍의 비대칭키(A: 공개키, B: 비밀키)를 사용하겠다. 우선 비밀키(A)는 서버만 가지고 있고, 절대 공개하지 않는다. 이와 반면에 공개키(A)는 공개되어 있어서, 누구든 쉽게 이 키를 구할 수 있다.</p>

<p><img alt="image" src="/images/86568c0b-a153-4dfc-87c8-f07d801e0da9" /></p>

<ol>
  <li>
    <p><strong>JWT 생성</strong></p>

    <p>Signature를 생성하는 과정에서 비밀 키(B)를 통해서 signatrue를 생성한다. 이 signature는 오로지 비밀 키(B)로만 만들 수 있고, 공개 키(A)로만 해독 할 수 있다.</p>
  </li>
  <li>
    <p><strong>JWT 소비</strong></p>

    <p>사용자는 서버로부터 전달 받은 base64 decoding으로 JWT의 header와 payload를 쉽게 복원할 수 있다. 그리고 sinature도 공개 키(A)를 통해서 복화할 수 있다.(사실 사용자가 signature를 복호화할 필요는 없다.)</p>
  </li>
  <li>
    <p><strong>제 3의 서비스</strong></p>

    <p>사용자가 JWT를 서버가 아니라 제 3의 서비스에게 전달한다고 해보자. 이 제3의 서비스는 사용자의 ID를 식별해야하고, 이것이 위조되지 않았는지 판단해야한다.</p>

    <p>제 3의 서비스는 원래 서버로부터 공개키를 받아왔다.</p>

    <p>이 공개 키(A)를 사용하면 사용자가 보낸 JWT의 signature를 복호화할 수 있다. 복호화한 결과가, JWT 속 header, payload와 일치 한다면, 이 JWT가 위조 되지 않았음이 증명된다. 이를 통해 인증 서버 없이 <strong>인가</strong>(Athorization)를 수행할 수 있다.</p>

    <p>제 3의 서버는 공개 키(A) 만으로 사용자의 JWT의 위조 여부를 판별한다.</p>
  </li>
</ol>

<h3 id="3-비대칭키-방식의-jwt-활용">3) 비대칭키 방식의 JWT 활용</h3>

<p>주로 <strong>Micro Service Architecture</strong>에서 이를 활용할 수 있다. 처음 id와 Password를 받아서 JWT를 발급해주는 <strong>인증서버</strong>를 분리하고, <strong>각각의 다른 어플리케이션</strong>들은 공개 키만 가지고 사용자가 제출한 JWT가 유효한지 그렇지 않은지 판단할 수 있다.</p>

<h3 id="reference">Reference</h3>

<ul>
  <li><a href="https://jwt.io/introduction">https://jwt.io/introduction</a></li>
  <li><a href="http://www.opennaru.com/opennaru-blog/jwt-json-web-token-with-microservice/">http://www.opennaru.com/opennaru-blog/jwt-json-web-token-with-microservice/</a></li>
  <li><a href="https://velopert.com/2389">https://velopert.com/2389</a></li>
</ul>

	</div>
	<br/>
	<br/>
	<script src="https://utteranc.es/client.js"
        repo="deagwon97/deagwon97.github.io"
        issue-term="url"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</article>
		</div>
	</div>
  </body>
</html>