<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="bdg-blog" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>bdg-blog</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">bdg-blog</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#쿠버네티스">
				<span class="name">쿠버네티스</span>
				<span class="badge">10</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#기타">
				<span class="name">기타</span>
				<span class="badge">8</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#운영체제/컴퓨터구조">
				<span class="name">운영체제/컴퓨터구조</span>
				<span class="badge">7</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#백앤드">
				<span class="name">백앤드</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#컨테이너">
				<span class="name">컨테이너</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Go">
				<span class="name">Go</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 아키텍쳐">
				<span class="name">클린 아키텍쳐</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#보안">
				<span class="name">보안</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#리눅스">
				<span class="name">리눅스</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#네트워크">
				<span class="name">네트워크</span>
				<span class="badge">4</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#자바스크립트">
				<span class="name">자바스크립트</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 코드">
				<span class="name">클린 코드</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			[Linux] exit 은 절대로 /etc/profile.d  속에 있으면 안 된다.
		</div>
		<time class="post-date dt-published" datetime="2023-07-26T20:24:27+09:00" itemprop="datePublished">2023/07/26
		</time>		
	</header>

	<div class="post-content">
		<p><img alt="image" src="/images/ab739486-6263-4eff-95e5-80a76c6b1c15" /></p>

<p>작업을 마무리하고 테스트를 위해서 서버에 다시 접속하려고 하는데, 다음과 같은 문제를 마주했다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@local ~% ssh server
user@local ~% <span class="c">#...?</span>
</code></pre></div></div>

<p>지금까지 잘 들어갈 수 있었던 서버가 갑자기 막혔다. 하지만, 뭔가 이상했다. 보통 서버가 죽거나, 인증 상의 오류가 있다면 터미널이 pending 되다가 어떤 메시지를 띄워준다. 하지만, 위의 예시처럼, 서버에 접속하자마자 로컬로 돌아왔다. 마치 서버에 들어가자마자 <code class="highlighter-rouge">exit</code> 커맨드를 실행한 것처럼 동작했다.</p>

<h3 id="무엇을-하고-있었나">무엇을 하고 있었나?</h3>

<p>서버는 여러 명의 사용자가 상시로 접속한다. 이 사용자 중 특정 사용자에게 개인화된 배너를 보여주는 기능을 만들고 있었다.</p>

<h3 id="어떤-방법을-선택했는가---etcprofile">어떤 방법을 선택했는가? - /etc/profile</h3>

<p>처음에는 motd를 알아보았다. 하지만, CentOS의 MOTD는 정적이기 때문에 모든 사용자에게 동일한 배너를 띄운다. 사용자 별로 개인화된 메시지를 보낼 수는 없었다.</p>

<p>이때, 모든 사용자가 로그인할 때, 항상 <code class="highlighter-rouge">/etc/profile</code> 스크립트가 실행되며, 이 스크립트는 <code class="highlighter-rouge">/etc/profile.d</code> 폴더 아래에 있는 모든 <code class="highlighter-rouge">*.sh</code> 파일을 실행한다는 것을 알게되었다. 이를 바탕으로  <code class="highlighter-rouge">/etc/profile.d</code> 폴더 아래에 다음과 같은 <code class="highlighter-rouge">message.sh</code> 파일을 추가해 개인화된 배너를 만들었다. <strong>여기서 문제가 발생했다.</strong> 아래 코드를 살펴보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">user_list</span><span class="o">=</span><span class="s2">"user1 user2 user3 user4 ..."</span>
<span class="nv">user_name</span><span class="o">=</span><span class="sb">``</span><span class="nb">whoami</span><span class="sb">``</span>

<span class="nv">is_in</span><span class="o">=</span>0
<span class="k">for </span>user <span class="k">in</span> <span class="nv">$user_list</span>
<span class="k">do
    if</span> <span class="o">[</span> <span class="nv">$user</span> <span class="o">=</span> <span class="nv">$user_name</span> <span class="o">]</span>
    <span class="k">then
        </span><span class="nv">is_in</span><span class="o">=</span>1
        <span class="nb">break
    </span><span class="k">fi
done
if</span> <span class="o">[</span> <span class="nv">$is_in</span> <span class="o">=</span> 1 <span class="o">]</span>
<span class="k">then
    </span><span class="nb">exit
</span><span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"안녕하세요 </span><span class="nv">$user_name</span><span class="s2"> 님 반갑습니다."</span>
<span class="nb">echo</span> <span class="s2">"~~를 제출하셔야합니다. ~으로 ~을 보내주세요."</span>
<span class="nb">echo</span> <span class="s2">""</span>
</code></pre></div></div>

<h3 id="문제의-원인">문제의 원인</h3>

<p><code class="highlighter-rouge">/etc/profile</code> 의 동작 방식을 알고 있는 사람들은 위 스크립트를 보고 깜짝 놀랐을 것이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">[</span> <span class="nv">$is_in</span> <span class="o">=</span> 1 <span class="o">]</span>
<span class="k">then
    </span><span class="nb">exit
</span><span class="k">fi</span>
</code></pre></div></div>

<p>만약 <code class="highlighter-rouge">/etc/profile</code> 스크립트가 <code class="highlighter-rouge">/etc/profile.d/*.sh</code> 파일들을 실행할 때, 개별 프로세스를 만들어서 실행 했다면, 위의 exit 구문은 문제가 없다. <code class="highlighter-rouge">user_name</code>이 <code class="highlighter-rouge">user_list</code> 에 들어있지 않다면 해당 프로세스를 종료하고, 그렇지 않으면 아래 <code class="highlighter-rouge">echo</code> 를 실행한다.</p>

<p>하지만 <code class="highlighter-rouge">/etc/profile.d/*.sh</code> 파일을 실행시키는 <code class="highlighter-rouge">/etc/profile</code> 는 새로운 프로세스를 생성하지 않는다.  파일속 문자열을 읽은 후 그대로 자신의 프로세스에서 코드를 수행한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>i <span class="k">in</span> /etc/profile.d/<span class="k">*</span>.sh /etc/profile.d/sh.local <span class="p">;</span> <span class="k">do
    if</span> <span class="o">[</span> <span class="nt">-r</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
        if</span> <span class="o">[</span> <span class="s2">"</span><span class="k">${</span><span class="p">-#*i</span><span class="k">}</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"</span><span class="nv">$-</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> 
            <span class="nb">.</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span>
        <span class="k">else</span>
            <span class="nb">.</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null
        <span class="k">fi
    fi
done</span>
</code></pre></div></div>

<p>쉬운 예시를 통해서 살펴보자. 우선 <a href="http://caller.sh">caller.sh</a>와 <a href="http://callee.sh">callee.sh</a> 파일을 작성한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">.</span>
├── callee.sh
└── caller.sh
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c"># callee.sh</span>

<span class="nb">echo</span> <span class="s2">"I'm callee"</span>

<span class="nb">exit</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c"># caller.sh</span>

<span class="nb">echo</span> <span class="s2">"I'm caller"</span>

sh ./callee.sh

<span class="nb">echo</span> <span class="s2">"after call"</span>
</code></pre></div></div>

<p>이제 <code class="highlighter-rouge">caller.sh</code> 파일을 실행한다면 어떤 결과가 나올까?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sh ./caller.sh 
I<span class="s1">'m caller
I'</span>m callee
after call
</code></pre></div></div>

<p>caller는 새로운 프로세스를 만들어서 callee를 실행했고, callee가 끝난 후(<code class="highlighter-rouge">exit</code>), <code class="highlighter-rouge">echo "after call"</code> 라인을 실행했다.</p>

<p>이제 <code class="highlighter-rouge">/etc/profile</code> 처럼 바꿔보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c"># caller.sh</span>

<span class="nb">echo</span> <span class="s2">"I'm caller!"</span>

<span class="k">**</span><span class="nv">callee</span><span class="o">=</span>./callee.sh
<span class="nb">.</span> <span class="s2">"</span><span class="nv">$callee</span><span class="s2">"</span><span class="k">**</span>

<span class="nb">echo</span> <span class="s2">"after call"</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c"># caller.sh</span>

<span class="nb">echo</span> <span class="s2">"I'm callee"</span>

<span class="nb">exit</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">caller.sh</code> 파일을 실행하면 다음과 같은 결과를 얻는다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>sh ./caller.sh 
I<span class="s1">'m caller
I'</span>m callee
</code></pre></div></div>

<p><code class="highlighter-rouge">echo "after call"</code> 이 실행되지 않고 caller가 종료되었다! caller는 callee를 새로운 프로세스에서 실행한 것이 아니다. callee일 읽어서 직접 실행했다. 이러면 <code class="highlighter-rouge">exit</code>은 callee 프로세스를 종료한다는 뜻이 아닌 caller를 종료하는 명령이 된다.</p>

<p>자 이제 다시 필자가 짠 코드를 확인해 보자.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">user_list</span><span class="o">=</span><span class="s2">"user1 user2 user3 user4 ..."</span>
<span class="nv">user_name</span><span class="o">=</span><span class="sb">``</span><span class="nb">whoami</span><span class="sb">``</span>

<span class="nv">is_in</span><span class="o">=</span>0
<span class="k">for </span>user <span class="k">in</span> <span class="nv">$user_list</span>
<span class="k">do
    if</span> <span class="o">[</span> <span class="nv">$user</span> <span class="o">=</span> <span class="nv">$user_name</span> <span class="o">]</span>
    <span class="k">then
        </span><span class="nv">is_in</span><span class="o">=</span>1
        <span class="nb">break
    </span><span class="k">fi
done
if</span> <span class="o">[</span> <span class="nv">$is_in</span> <span class="o">=</span> 1 <span class="o">]</span>
<span class="k">then
    </span><span class="nb">exit
</span><span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"안녕하세요 </span><span class="nv">$user_name</span><span class="s2"> 님 반갑습니다."</span>
<span class="nb">echo</span> <span class="s2">"~~를 제출하셔야합니다. ~으로 ~을 보내주세요."</span>
<span class="nb">echo</span> <span class="s2">""</span>
</code></pre></div></div>

<p>그렇다! 필자가 작성한 코드는 <code class="highlighter-rouge">user_list</code>에 속하지 않는 사용자는 로그인하는 즉시 <code class="highlighter-rouge">exit</code>하는 코드이다! 그리고 저 <code class="highlighter-rouge">user_list</code> 속에는 <code class="highlighter-rouge">root</code>도 없었고, <code class="highlighter-rouge">sudo</code> 권한을 가진 사용자가 아무도 없었다.</p>

<p><code class="highlighter-rouge">/etc/profile.d/message.sh</code> 파일을 지울 방법을 찾아봤다. 하지만, 모든 <code class="highlighter-rouge">root</code> 터미널을 종료한 상태였고, <code class="highlighter-rouge">sudo</code> 권한이 없는 사용자가 <code class="highlighter-rouge">message.sh</code> 파일에 접근하는 법 따위는 존재하지 않았다.</p>

<p>이 운영체제가 보호하는 한, <code class="highlighter-rouge">root</code> 권한 없이 <code class="highlighter-rouge">message.sh</code> 파일을 지울 방법이 생각나지 않았다.</p>

<p>급하게 USB를 구해서 Ubuntu의 라이브 USB를 만들었다. 그리고 모니터, 키보드, usb를 들고 서버실에 들어갔다. BIOS 모드에서 부팅 디스크를 USB로 바꾼 후, 부팅하면 데이터는 그대로 둔 상태에서 Ubuntu가 부팅된다. 이제 볼륨을 마운트하고, <code class="highlighter-rouge">root</code> 권한으로 <code class="highlighter-rouge">/etc/profile.d/message.sh</code> 파일을 제거했다.</p>

<h3 id="etcprofile-왜-이렇게-동작할까">/etc/profile 왜 이렇게 동작할까?</h3>

<p><code class="highlighter-rouge">/etc/profile</code> 는 <code class="highlighter-rouge">profile.d</code> 폴더 속 스크립트를 읽어와, Linux 시스템의 환경 및 기타 커스텀 설정을 수행하는 도구이다.  스크립트 들의 실행결과가 유지돼야 하기 때문에, <code class="highlighter-rouge">profile</code>은 새로운 프로세스를 생성하지 않고, 폴더 속 코드를 읽어와서 직접 실행한다.</p>

<h3 id="다른-해결방법-1">다른 해결방법 1</h3>

<p>다음날 찾아보니 <code class="highlighter-rouge">/etc/profile.d</code> 속 스크립트를 실행하지 않고 로그인 하는 방법이 있다고 한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-t</span> root@host bash <span class="nt">--noprofile</span>
<span class="c"># or</span>
su root bash  <span class="nt">--noprofile</span>
</code></pre></div></div>

<p>하지만 이 방법은 root 계정으로 ssh 로그인이 가능할 때, 쓸 수 있는 반쪽짜리 방법이다.</p>

<h3 id="다른-해결방법-2">다른 해결방법 2</h3>
<p>centos에서도 안전모드로 들어가는 방법이 존재한다. 다른 부팅 usb를 구할 필요 없이, 노드에 키보드와 모니터만 연결할 수 있다면, 안전모드로 들어가 message.sh를 지울 수 있다.</p>

<h3 id="반성">반성</h3>

<p>필자는 <code class="highlighter-rouge">/etc/profile.d</code> 속에 <code class="highlighter-rouge">message.sh</code>를 추가할 때, <code class="highlighter-rouge">profile</code> 이 어떤 방식으로 <code class="highlighter-rouge">profile.d</code>를 읽는지 알아보지 않았다. 이 때문에 대형 사고를 쳤다. 서버의 <code class="highlighter-rouge">/etc</code> 폴더를 건드리는 작업은 정말 신중을 가해야 한다. 또한 새로운 도구를 사용할 때, 이 <strong>도구가 왜 만들어졌고</strong>, <strong>어떻게 동작하는 지</strong>를 충분히 이해하고 사용해야 한다.</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://askubuntu.com/questions/63741/can-i-ssh-into-my-account-without-invoking-profile">https://askubuntu.com/questions/63741/can-i-ssh-into-my-account-without-invoking-profile</a></li>
  <li><a href="https://serverfault.com/questions/434321/when-are-scripts-inside-etc-profile-d-executed">https://serverfault.com/questions/434321/when-are-scripts-inside-etc-profile-d-executed</a></li>
  <li>[https://eng.libretexts.org/Bookshelves/Computer_Science/Operating_Systems/Linux_-<em>The_Penguin_Marches_On</em>(McClanahan)/02%3A_User_Group_Administration/5.03%3A_System_Wide_User_Profiles/5.03.2<em>System_Wide_User_Profiles%3A_The_etc-profile.d_Directory](https://eng.libretexts.org/Bookshelves/Computer_Science/Operating_Systems/Linux</em>-<em>The_Penguin_Marches_On</em>(McClanahan)/02%3A_User_Group_Administration/5.03%3A_System_Wide_User_Profiles/5.03.2_System_Wide_User_Profiles%3A_The_etc-profile.d_Directory)</li>
  <li><a href="https://forums.fedoraforum.org/showthread.php?317937-Never-put-exit-in-a-etc-profile-d-script">https://forums.fedoraforum.org/showthread.php?317937-Never-put-exit-in-a-etc-profile-d-script</a></li>
  <li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=739991">https://bugzilla.redhat.com/show_bug.cgi?id=739991</a></li>
</ul>

	</div>
	<br/>
	<br/>
	<script src="https://utteranc.es/client.js"
        repo="deagwon97/deagwon97.github.io"
        issue-term="url"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</article>
		</div>
	</div>
  </body>
</html>