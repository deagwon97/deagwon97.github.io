<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="bdg-blog" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>bdg-blog</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/">bdg-blog</a>
	</div>
	<p class="lead"></p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#쿠버네티스">
				<span class="name">쿠버네티스</span>
				<span class="badge">10</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#기타">
				<span class="name">기타</span>
				<span class="badge">8</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#운영체제/컴퓨터구조">
				<span class="name">운영체제/컴퓨터구조</span>
				<span class="badge">7</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#백앤드">
				<span class="name">백앤드</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#컨테이너">
				<span class="name">컨테이너</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Go">
				<span class="name">Go</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 아키텍쳐">
				<span class="name">클린 아키텍쳐</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#보안">
				<span class="name">보안</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#리눅스">
				<span class="name">리눅스</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#네트워크">
				<span class="name">네트워크</span>
				<span class="badge">4</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#자바스크립트">
				<span class="name">자바스크립트</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#클린 코드">
				<span class="name">클린 코드</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			[Go] Embedding
		</div>
		<time class="post-date dt-published" datetime="2023-07-26T20:25:45+09:00" itemprop="datePublished">2023/07/26
		</time>		
	</header>

	<div class="post-content">
		<h2 id="상속과-컴포지션">상속과 컴포지션</h2>

<p><img alt="image" src="/images/7b961ede-3090-4e24-9550-e4cc020b1afc" /></p>

<p>이미 정의한 타입(무언가)을 재활용하여 새로운 타입(무언가)을 만드는 방법으로 <strong>상속</strong>과 <strong>컴포지션</strong>이 있다. 많은 언어에서 이 두 가지를 지원한다.</p>

<ul>
  <li><strong>상속</strong>: 하위 클래스가 상위 클래스의 특성을 재정의, (IS-A) 관계</li>
  <li><strong>컴포지션</strong>: 하위 클래스가 상위 클래스를 포함, (HAS-A) 관계</li>
</ul>

<p>많은 언어가 이미 정의된 타입을 참고하여 새로운 타입을 정의할 때, 상속을 주로 사용하였다. 하지만 이러한 상속은 몇 가지 문제점을 가지고 있다.</p>

<ul>
  <li>Open Close 원칙을 위반할 수 있다.
    <ul>
      <li>객체지향프로그래밍은 기존의 코드를 클래스를 수정하지 말고, 기능을 추가하는 방식으로 프로그래밍하는 것을 지향한다. 하지만, 상속은 오버라이딩을 통해서 부모 클래스의 함수를 “수정”할 수 있으며, 이는 개방폐쇄 원칙을 위반한다.</li>
    </ul>
  </li>
  <li>캡슐화를 위반할 수 있다.
    <ul>
      <li>자식 클래스가 부모 클래스를 수정하는 경우, 부모 클래스의 내부 동작에 접근하여 동작을 수정하는 경우가 생긴다. 이는 캡슐화를 위반한다.</li>
    </ul>
  </li>
</ul>

<p>컴포지션은 원래 클래스를 수정할 수 없기 때문에 개방폐쇄 원칙을 강제한다. 또한  원래 클래스가 캡슐화를 잘 지켜서 만들었다면, 이를 포함하는 새로운 클래스는 원래 클래스의 내부동작에 간섭하지 못함으로 캡슐화 또한 지켜진다. 많은 개발자들이 상속의 문제점에 공감하였고, 따라서 Go는 상속기능을 지원하지 않고, 오로지 컴포지션(Go Embedding) 기능만을 지원하도록 설계되었다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Base</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span>  <span class="kt">string</span>
	<span class="n">Value</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EmbedsBase</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Base</span>
	<span class="n">Other</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="타입-임베딩-vs-포인터-임베딩">타입 임베딩 vs 포인터 임베딩</h2>

<p>임베딩을 할 때 두 가지 방법이 존재한다. 하나는 타입을 임베딩하는 방식이고, 다른 하나는 타입의 포인터를 임베딩하는 방식이다.</p>

<h3 id="타입-임베딩">타입 임베딩</h3>

<p>EmbedsBase 는 Base의 Name과 Value를 모두 가지는 새로운 타입이다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Base</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span>  <span class="kt">string</span>
	<span class="n">Value</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EmbedsBase</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Base</span>
	<span class="n">Other</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="포인터-임베딩">포인터 임베딩</h3>

<p>EmbedsPointerToBase 는 Base의 포인터를 변수로 갖는 새로운 타입이다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Base</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span>  <span class="kt">string</span>
	<span class="n">Value</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EmbedsPointerToBase</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="n">Base</span>
	<span class="n">Other</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="비교">비교</h2>

<ul>
  <li><a href="https://stackoverflow.com/questions/28501976/embedding-in-go-with-pointer-or-with-value">https://stackoverflow.com/questions/28501976/embedding-in-go-with-pointer-or-with-value</a></li>
</ul>

<p>위의 질문을 보면 타입 임베딩과 포인터 임베딩에 대한 여러 개발자의 의견을 엿볼 수 있다. 정리해 보면, 두 방식은 객체 생성 및 전달에서 차이가 있으며, 객체의 내부 변수에 어떻게 접근하고 싶은가에 따라 선택적으로 사용하면 된다고 한다.</p>

<p>Base의 메서드가 Base 의 값을 제어하고, 이때 이 Base를 임베딩한 EmbedsBase 객체를 값으로 넘기는 특수한 함수를 가정하면, 이 함수 내부에서 Base를 조작하는 것은 외부에 영향을 주지 못한다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Base</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span>  <span class="kt">string</span>
	<span class="n">Value</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="n">Base</span><span class="p">)</span> <span class="n">PrintBase</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EmbedsBase</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Base</span>
	<span class="n">Other</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ControlEmbedsBaseValue</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span><span class="n">EmbedsBase</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">value</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">"other name"</span>
	<span class="n">value</span><span class="o">.</span><span class="n">PrintBase</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">b</span> <span class="o">:=</span> <span class="n">Base</span><span class="p">{</span><span class="s">"name"</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
	<span class="n">eb</span> <span class="o">:=</span> <span class="n">EmbedsBase</span><span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="s">"other"</span><span class="p">}</span>
	<span class="n">ControlEmbedsBaseValue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eb</span><span class="p">)</span> <span class="c">// other name 2 출력</span>
	<span class="n">eb</span><span class="o">.</span><span class="n">PrintBase</span><span class="p">()</span>              <span class="c">// name 2       출력</span>
<span class="p">}</span>
</code></pre></div></div>

<p>하지만, 포인터를 임베딩한 EmbedsPointerToBase 을 사용하면, 값을 넘기더라도 ControlEmbedsBaseValue함수로 EmbedsPointerToBase의 Name 변수를 제어할 수 있다.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Base</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Name</span>  <span class="kt">string</span>
	<span class="n">Value</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="n">Base</span><span class="p">)</span> <span class="n">PrintBase</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EmbedsPointerToBase</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">Base</span>
	<span class="n">Other</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">ControlEmbedsBaseValue</span><span class="p">(</span><span class="n">value</span> <span class="n">EmbedsPointerToBase</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">value</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">"other name"</span>
	<span class="n">value</span><span class="o">.</span><span class="n">PrintBase</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">b</span> <span class="o">:=</span> <span class="n">Base</span><span class="p">{</span><span class="s">"name"</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
	<span class="n">eb</span> <span class="o">:=</span> <span class="n">EmbedsBase</span><span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="s">"other"</span><span class="p">}</span>
	<span class="n">ControlEmbedsBaseValue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eb</span><span class="p">)</span> <span class="c">// other name 2 출력</span>
	<span class="n">eb</span><span class="o">.</span><span class="n">PrintBase</span><span class="p">()</span>              <span class="c">// other name 2 출력</span>
<span class="p">}</span>
</code></pre></div></div>

<p>장황하게 예시를 들었지만, Go의 함수 동작을 이해하면 당연한 동작이다.</p>

<p>Go는 함수를 실행하는 순간에 외부에서 전달받은 변수를 복사하여 함수 안에 새롭게 생성한다. 만약 전달받은 값이 포인터이고, 이 포인터를 통해서 변수를 조작했다면, 외부 변수에 영향을 줄 것이다. 반대로 전달받은 값이 단순한 변수라면, 이 변수를 조작 하더라도 외부 변수에 영향을 줄 수 없다. 이를 이해하고 상황에 따라 선택적으로 사용하면 된다.</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://stackoverflow.com/questions/28501976/embedding-in-go-with-pointer-or-with-value">https://stackoverflow.com/questions/28501976/embedding-in-go-with-pointer-or-with-value</a></li>
  <li><a href="https://incheol-jung.gitbook.io/docs/q-and-a/architecture/undefined-2">https://incheol-jung.gitbook.io/docs/q-and-a/architecture/undefined-2</a></li>
  <li><a href="https://smjeon.dev/etc/composite-extends/">https://smjeon.dev/etc/composite-extends/</a></li>
</ul>

	</div>
	<br/>
	<br/>
	<script src="https://utteranc.es/client.js"
        repo="deagwon97/deagwon97.github.io"
        issue-term="url"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</article>
		</div>
	</div>
  </body>
</html>